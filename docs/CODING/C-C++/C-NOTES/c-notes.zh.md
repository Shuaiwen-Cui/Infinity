# C 语言学习笔记

## 目录

CH1 - 导言
CH2 - 类型、运算符与表达式
CH3 - 控制流
CH4 - 函数与程序结构
CH5 - 指针与数组
CH6 - 结构
CH7 - 输入与输出
CH8 - UNIX 系统接口

## CH1 - 导言

一些简单案例。

## CH2 - 类型、运算符与表达式
- **变量**和**常量**是程序处理的两种基本数据对象。
- **声明语句**说明变量的名字及类型，也可以指定变量的初值。
- **运算符**指定将要进行的操作。
- **表达式**则把变量与常量组合起来生成新的值。
- 对象的**类型**决定该对象可取值的集合以及可以对该对象执行的操作。

### 2.1 变量名
对变量的命名与符号常量的命名存在一些限制条件：
- 名字是由字母和数字组成的序列，但其第一个字符必须为字母
  - 下划线“_”被看做是字母，通常用于命名较长的变量名，以提高其可读性
  - 由于例程的名字通常以下划线开头，因此变量名不要以下划线开头
- 大写字母与小写字母是有区别的
  - 通常，变量名用小写字母，符号常量用大写字母
- 选择的变量名要能够尽量从字面上表达变量的用途，这样做不容易引起混淆。
  - 局部变量一般使用较短的变量名（尤其是循环控制变量）
  - 外部变量使用较长的名字

### 2.2 数据类型及长度
C 语言只提供了下列几种基本数据类型：

- char 字符型，一个字节, 可以存放本地字符集中的一个字符
- int 整型，通常反映了所用机器中整数的最自然长度 
- float 单精度浮点型
- double 双精度浮点型

此外，还可以在这些基本数据类型的前面加上一些限定符。short 与 long 两个限定符用于限定整型：

short int sh;
long int counter;

在上述这种类型的声明中，关键字 int 可以省略。通常很多人也习惯这么做。

short 与 long 两个限定符的引入可以为我们提供满足实际需要的不同长度的整型数。int 通常代表特定机器中整数的自然长度。short 类型通常为 16 位，1ong 类型通常为 32位，int 类型可以为 16 位或 32 位。各编译器可以根据硬件特性自主选择合适的类型长度，但要遵循下列限制：short 与 int 类型至少为 16 位，而 long 类型至少为 32 位，并且 short类型不得长于 int 类型，而 int 类型不得长于 long 类型。

类型限定符 signed 与 unsigned 可用于限定 char 类型或任何整型。unsigned 类型的数总是正值或 0，并遵守算术模 2^n定律，其中 n 是该类型占用的位数。例如，如果 char 对象占用 8 位，那么 unsigned char 类型变量的取值范围为 0～255，而 signed char 类型变量的取值范围则为-128～127（在采用对二的补码的机器上）。不带限定符的 char 类型对象是否带符号则取决于具体机器，但可打印字符总是正值。

### 2.3 常量

#### 整数常量

整数常量属于 int 类型。long 类型的常量以字母 l 或 L 结尾，如123456789L。如果一个整数太大以至于无法用 int 类型表示时，也将被当作 long 类型处理。无符号常量以字母 u 或 U 结尾。后缀 ul 或 UL 表明是 unsigned long 类型。

整型数除了用十进制表示外，还可以用八进制或十六进制表示。带前缀 0 的整型常量表示它为八进制形式；前缀为 0x 或 0X，则表示它为十六进制形式。

#### 浮点数常量

浮点数常量中包含一个小数点（如 123.4）或一个指数（如 1e-2），也可以两者都有。没有后缀的浮点数常量为 double 类型。后缀 f 或 F 表示 float 类型，而后缀 l 或 L 则表示 long double 类型。

#### 字符常量

一个字符常量是一个整数，书写时将一个字符括在单引号中。如果用字符'0'代替这个与具体字符集有关的值（比如 48），那么，程序就无需关心该字符对应的具体值，增加了程序的易读性。字符常量一般用来与其它字符进行比较，但也可以像其它整数一样参与数值运算。

!!! info "转义字符"
    ANSI C 语言中的全部转义字符序列如下所示：

    \a 响铃符       \\\\ 反斜杠

    \b 回退符       \? 问号

    \f 换页符       \' 单引号

    \n 换行符       \" 双引号
    
    \r 回车符       \ooo 八进制数

    \t 横向制表符   \xhh 十六进制数

    \v 纵向制表符

字符常量'\0'表示值为 0 的字符，也就是空字符（null）。我们通常用'\0'的形式代替 0，以强调某些表达式的字符属性，但其数字值为 0。

常量表达式是仅仅只包含常量的表达式。这种表达式在编译时求值，而不在运行时求值。它可以出现在常量可以出现的任何位置。

#### 字符串常量

字符串常量或字符串字面量以双引号括起来的字符序列表示。字符串常量是一个字符数组。字符串的内部表示在末尾有一个空字符'\0'，因此所需的物理存储比引号之间写入的字符数多一个。这种表示也解释了为什么字符串的长度没有限制；程序只需要扫描内存，直到找到'\0'来确定长度。标准库函数strlen(s)返回其字符串参数的长度，不包括'\0'。

我们应该搞清楚字符常量与仅包含一个字符的字符串之间的区别：'x'与"x"是不同的。前者是一个整数，其值是字母 x 在机器字符集中对应的数值（内部表示值）；后者是一个包含一个字符（即字母 x）以及一个结束符'\0'的字符数组。

#### 枚举常量

枚举常量是一种特殊的整型常量。枚举常量是由用户定义的标识符的列表。关键字 enum 说明符用于定义枚举类型，其形式为：

enum 枚举名 {枚举常量表}；

枚举常量表中的第一个枚举常量的默认值为 0，后续枚举常量的值依次加 1。枚举常量的值可以在定义时显式地赋值。如果没有显式地赋值，那么枚举常量的值将比前一个枚举常量的值大 1。枚举常量的值必须是整型常量，且不能重复。

枚举常量的作用域与其它变量的作用域相同，即从定义处到该枚举常量所在的块的结束处。枚举常量的类型为 int。

### 2.4 声明

所有变量都必须先声明后使用，尽管某些变量可以通过上下文隐式地声明。一个声明指定一种变量类型，后面所带的变量表可以包含一个或多个该类型的变量。

一个声明语句中的多个变量可以拆开在多个声明语句中声明。按照这种形式书写代码需要占用较多的空间，但便于向各声明语句中添加注释，也便于以后修改。

还可以在声明的同时对变量进行初始化。在声明中，如果变量名的后面紧跟一个等号以及一个表达式，该表达式就充当对变量进行初始化的初始化表达式。

如果变量不是自动变量，则只能进行一次初始化操作，从概念上讲，应该是在程序开始执行之前进行，并且初始化表达式必须为常量表达式。每次进入函数或程序块时，显式初始化的自动变量都将被初始化一次，其初始化表达式可以是任何表达式。默认情况下，外部变量与静态变量将被初始化为 0。未经显式初始化的自动变量的值为未定义值（即无效值）。

任何变量的声明都可以使用 const 限定符限定。该限定符指定变量的值不能被修改。对数组而言，const 限定符指定数组所有元素的值都不能被修改。const 限定符的使用可以提高程序的可读性，也可以帮助编译器检查程序中的错误。

### 2.5 算术运算符
二元算术运算符包括：+、-、*、/、%（取模运算符）。整数除法会截断结果中的小数部分。表达式 x % y 的结果是 x 除以 y 的余数，当 x 能被 y 整除时，其值为 0。

取模运算符%不能应用于 float 或 double 类型。在有负操作数的情况下，整数除法截取的方向以及取模运算结果的符号取决于具体机器的实现，这和处理上溢或下溢的情况是一样的。

二元运算符+和-具有相同的优先级，它们的优先级比运算符*、/和%的优先级低，而运算符*、/和%的优先级又比一元运算符+和-的优先级低。算术运算符采用从左到右的结合规则。

### 2.6 关系运算符与逻辑运算符
关系运算符包括下列几个运算符：
\> >= < <= 
它们具有相同的优先级。优先级仅次于它们的是相等性运算符：
== != 
关系运算符的优先级比算术运算符低。

逻辑运算符&&与||有一些较为特殊的属性，由&&与||连接的表达式按从左到右的顺序进行求值，并且，在知道结果值为真或假后立即停止计算。绝大多数 C 语言程序运用了这些属性。

根据定义，在关系表达式或逻辑表达式中，如果关系为真，则表达式的结果值为数值 1；如果为假，则结果值为数值 0。

### 2.7 类型转换
当一个运算符的几个操作数类型不同时，就需要通过一些规则把它们转换为某种共同的类型。一般来说，自动转换是指把“比较窄的”操作数转换为“比较宽的”操作数，并且不丢失信息的转换。不允许使用无意义的表达式，例如，不允许把 float 类型的表达式作为下标。针对可能导致信息丢失的表达式，编译器可能会给出警告信息，比如把较长的整型值赋给较短的整型变量，把浮点型值赋值给整型变量，等等，但这些表达式并不非法。

由于 char 类型就是较小的整型，因此在算术表达式中可以自由使用 char 类型的变量，这就为实现某些字符转换提供了很大的灵活性，比如，下面的函数 atoi 就是一例，它将一串数字转换为相应的数值。

将字符类型转换为整型时，我们需要注意一点。C 语言没有指定 char 类型的变量是无符号变量（signed）还是带符号变量（unsigned）。当把一个 char 类型的值转换为 int 类型的值时，其结果有没有可能为负整数？对于不同的机器，其结果也不同，这反映了不同机器结构之间的区别。在某些机器中，如果 char 类型值的最左一位为 1，则转换为负整数（进行“符号扩展”）。而在另一些机器中，把 char 类型值转换为 int 类型时，在 char 类型值的左边添加 0，这样导致的转换结果值总是正值。

C 语言的定义保证了机器的标准打印字符集中的字符不会是负值，因此，在表达式中这些字符总是正值。但是，存储在字符变量中的位模式在某些机器中可能是负的，而在另一些机器上可能是正的。为了保证程序的可移植性，如果要在 char 类型的变量中存储非字符数据，最好指定 signed 或 unsigned 限定符。

C 语言中，很多情况下会进行**隐式的算术类型转换**。一般来说，如果二元运算符（具有两个操作数的运算符称为二元运算符，比如+或*）的两个操作数具有不同的类型，那么在进行运算之前先要把“较低”的类型提升为“较高”的类型，运算的结果为较高的类型。

赋值时也要进行类型转换。赋值运算符右边的值需要转换为左边变量的类型，左边变量的类型即赋值表达式结果的类型。
前面提到过，无论是否进行符号扩展，字符型变量都将被转换为整型变量。当把较长的整数转换为较短的整数或 char 类型时，超出的高位部分将被丢弃。

在任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显式类型转换。在下列语句中，表达式将按照上述转换规则被转换为类型名指定的类型：

(类型名) 表达式

### 2.8 自增与自减运算符
C 语言提供了两个用于变量递增与递减的特殊运算符。自增运算符++使其操作数递增 1，自减运算符使其操作数递减 1。

++与--这两个运算符特殊的地方主要表现在：它们既可以用作前缀运算符（用在变量前面，如++n）。也可以用作后缀运算符（用在变量后面，如 n++）。在这两种情况下，其效果都是将变量 n 的值加 1。但是，它们之间有一点不同。表达式++n 先将 n 的值递增 1，然后再使用变量 n 的值，而表达式 n++则是先使用变量 n 的值，然后再将 n 的值递增 1。

### 2.9 位运算符
C 语言提供了 6 个位操作运算符。这些运算符只能作用于整型操作数，即只能作用于带符号或无符号 char、short、int、long 类型：

- & 按位与（AND）
- | 按位或（OR）
- ^ 按位异或（XOR）
- << 左移
- >> 右移
- ~ 按位求反（一元运算符）

按位与运算符&经常用于屏蔽某些二进制位，例如：n = n & 0177;
该语句将 n 中除 7 个低二进制位外的其它各位均置为 0。

按位或运算符|常用于将某些二进制位置为 1，例如：x = x | SET_ON；
该语句将 x 中对应于 SET_ON 中为 1 的那些二进制位置为 1。

按位异或运算符^当两个操作数的对应位不相同时将该位设置为 1，否则，将该位设置为0。 
我们必须将位运算符&、|同逻辑运算符&&、||区分开来，后者用于从左至右求表达式的真值。例如，如果 x 的值为 1，Y 的值为 2，那么，x & y 的结果为 0，而 x && y 的值为 1

移位运算符<<与>>分别用于将运算的左操作数左移与右移，移动的位数则由右操作数指
定（右操作数的值必须是非负值）。因此，表达式 x << 2 将把 x 的值左移 2 位，右边空出的
2 位用 0 填补，该表达式等价于对左操作数乘以 4。

一元运算符~用于求整数的二进制反码，即分别将操作数各二进制位上的 1 变为 0，0 变为 1。

### 2.10 赋值运算符与表达式
大多数二元运算符（即有左、右两个操作数的运算符，比如+）都有一个相应的赋值运算符 op=，其中，op 可以是下面这些运算符之一：

`+ - * / % << >> & ^ |`

如果 expr1 和 expr2 是表达式，那么
`expr1 op= expr2` 

等价于：
`expr1 = (expr1) op (expr2)`


### 2.11 条件表达式

条件表达式 if-else 的一般形式为：

```c

if (表达式 1)
    语句 1
else if (表达式 2)
    语句 2
else if (表达式 3)
    语句 3
```

条件表达式形式（三元）：

`expr1 ? expr2 : expr3`

### 2.12 运算符优先级与求值次序

运算符优先级与求值次序表：

|               运算符               |                                                       含义                                                       |  优先级  |
| :--------------------------------: | :--------------------------------------------------------------------------------------------------------------: | :------: |
|             () [] -> .             |                                        括号、下标、结构成员、结构指针成员                                        | 从左到右 |
|  ! ~ ++ -- + - * & (类型) sizeof   |                 逻辑非、按位求反、自增、自减、正负号、间接寻址、取地址、强制类型转换、求字节长度                 | 从右到左 |
|               * / %                |                                                   乘、除、求余                                                   | 从左到右 |
|                + -                 |                                                      加、减                                                      | 从左到右 |
|               << >>                |                                                    左移、右移                                                    | 从左到右 |
|             < <= > >=              |                                          小于、小于等于、大于、大于等于                                          | 从左到右 |
|               == !=                |                                                   等于、不等于                                                   | 从左到右 |
|                 &                  |                                                      按位与                                                      | 从左到右 |
|                 ^                  |                                                     按位异或                                                     | 从左到右 |
|                 \|                 |                                                      按位或                                                      | 从左到右 |
|                 &&                 |                                                      逻辑与                                                      | 从左到右 |
|                \|\|                |                                                      逻辑或                                                      | 从左到右 |
|                 ?:                 |                                                    条件表达式                                                    | 从右到左 |
| = += -= *= /= %= <<= >>= &= ^= \|= | 赋值、赋值求和、赋值求差、赋值求积、赋值求商、赋值求余、赋值左移、赋值右移、赋值按位与、赋值按位异或、赋值按位或 | 从右到左 |
|                 ,                  |                                                       逗号                                                       | 从左到右 |

## CH3 - 控制流
程序语言中的控制流语句用于控制各计算操作执行的次序。

### 3.1 语句与程序块

#### 语句
在 x = 0、i++或 printf(...)这样的表达式之后加上一个分号（;），它们就变成了
语句。在 C 语言中，分号是语句结束符，而 Pascal 等语言却把分号用作语句之间的分隔符。

#### 程序块
用一对花括号“{”与“}”把一组声明和语句括在一起就构成了一个复合语句（也叫作程序块），复合语句在语法上等价于单条语句。右花括号用于结束程序块，其后不需要分号。

### 3.2 if-else 语句

```c
if {表达式} 
  语句 1 
else 
  语句 2
```

其中 else 部分是可选的。该语句执行时，先计算表达式的值，如果其值为真（即表达式的值
为非 0），则执行语句 1；如果其值为假（即表达式的值为 0），并且该语句包含 else 部分，
则执行语句 2。

由于 if 语句只是简单测试表达式的数值，因此可以对某些代码的编写进行简化。最明显
的例子是用如下写法
  if (表达式) 
来代替
  if (表达式 !0) 
某些情况下这种形式是自然清晰的，但也有些情况下可能会含义不清。

因为 if-else 语句的 else 部分是可选的，所以在嵌套的 if 语句中省略它的 else 部分将导致歧义。解决的方法是将每个 else 与最近的前一个没有 else 配对的 if 进行匹配。可以使用花括号来明确地指定 else 与哪个 if 匹配。

### 3.3 else-if 语句

```c
if (表达式) 
  语句
else if (表达式) 
  语句
else if (表达式) 
  语句
else if (表达式) 
  语句
else 
  语句
```
因此我们在这里单独说明一下。这种 if 语句序列是编写多路判定最常用的方法。其中的各表达式将被依次求值，一旦某个表达式结果为真，则执行与之相关的语句，并终止整个语句序列的执行。同样，其中各语句既可以是单条语句，也可以是用花括号括住的复合语句。

最后一个 else 部分用于处理“上述条件均不成立”的情况或默认情况，也就是当上面各条件都不满足时的情形。有时候并不需要针对默认情况执行显式的操作，这种情况下，可以把该结构末尾的
`else 语句` 部分省略掉；该部分也可以用来检查错误，以捕获“不可能”的条件。

### 3.4 switch 语句
!!! note "switch 语句"
    switch 语句是一种多路判定语句，它测试表达式是否与一些常量整数值中的某一个值匹配，并执行相应的分支动作。

```c
switch (表达式) { 
  case 常量表达式: 语句序列
  case 常量表达式: 语句序列
  default: 语句序列
}
```

每一个分支都由一个或多个**整数值常量**或**常量表达式**标记。如果某个分支与表达式的值匹配，则从该分支开始执行。各分支表达式必须互不相同。如果没有哪一分支能匹配表达式，则执行标记为 default 的分支。default 分支是可选的。如果没有 default 分支也没有其它分支与表达式的值匹配，则该 switch 语句不执行任何动作。各分支及 default 分支的排列次序是任意的。

例子：

```c
#include <stdio.h>
main() /* count digits, white space, others */
{
    int c, i, nwhite, nother, ndigit[10];
    nwhite = nother = 0;
    for (i = 0; i < 10; i++)
        ndigit[i] = 0;
    while ((c = getchar()) != EOF)
    {
        switch (c)
        {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            ndigit[c - '0']++;
            break;
        case ' ':
        case '\n':
        case '\t':
            nwhite++;
            break;
        default:
            nother++;
            break;
        }
    }
    printf("digits =");
    for (i = 0; i < 10; i++)
        printf(" %d", ndigit[i]);
    printf(", white space = %d, other = %d\n",
           nwhite, nother);
    return 0;
}
```

break 语句将导致程序的执行立即从 switch 语句中退出。**在 switch 语句中，case的作用只是一个标号，因此，某个分支中的代码执行完后，程序将进入下一分支继续执行，除非在程序中显式地跳转。**跳出 switch 语句最常用的方法是使用 break 语句与 return 语句。break 语句还可强制控制从 while、for 与 do 循环语句中立即退出。

依次执行各分支的做法有优点也有缺点。好的一面是它可以把若干个分支组合在一起完成一个任务，如上例中对数字的处理。但是，正常情况下为了防止直接进入下一个分支执行，每个分支后必须以一个 break 语句结束。从一个分支直接进入下一个分支执行的做法并不健全，这样做在程序修改时很容易出错。除了一个计算需要多个标号的情况外，应尽量减少从一个分支直接进入下一个分支执行这种用法，在不得不使用的情况下应该加上适当的程序注释。

作为一种良好的程序设计风格，在 switch 语句最后一个分支（即 default 分支）的后面也加上一个 break 语句。这样做在逻辑上没有必要，但当我们需要向该 switch 语句后添加其它分支时，这种防范措施会降低犯错误的可能性。

### 3.5 while 循环与 for 循环

在 while 循环语句
```c
while (表达式) 
  语句
```
中，首先求表达式的值。如果其值非 0，则执行语句，并再次求该表达式的值。这一循环过程
一直进行下去，直到该表达式的值为 0 为止，随后继续执行语句后面的部分。

```c
for 循环语句; 
for (表达式 1; 表达式 2; 表达式 3) 
语句
```
等价于

```c
表达式 1;
while (表达式 2) {
  语句
  表达式 3;
}
```
!!! warning "注意"
    当 while 或 for 循环语句中包含 continue 语句时，上述二者之间就不一定等价了。

从语法角度看，for 循环语句的 3 个组成部分都是表达式。最常见的情况是，表达式 1
与表达式 3 是赋值表达式或函数调用，表达式 2 是关系表达式。这 3 个组成部分中的任何部
分都可以省略，但分号必须保留。如果在 for 语句中省略表达式 1 与表达式 3，它就退化成
了 while 循环语句。如果省略测试条件，即表达式 2，则认为其值永远是真值，因此，下列
for 循环语句：
```c
for ( ; ; ) 
  语句
```
是一个“无限”循环语句，这种语句需要借助其它手段（如 break 语句或 return 语句）才
能终止执行。

在设计程序时到底选用 while 循环语句还是 for 循环语句，主要取决于程序设计人员的个人偏好。

例如，在下列语句中：
```c
 while ((c = getchar()) == ' ' || c == '\n' || c = '\t') 
 ; /* skip white space characters */ 
```
因为其中没有初始化或重新初始化的操作，所以使用 whi1e 循环语句更自然一些。

如果语句中需要执行简单的初始化和变量递增，使用 for 语句更合适一些，它将循环控制语句集中放在循环的开头，结构更紧凑、更清晰。通过下列语句可以很明显地看出这一点：
```c
 for (i = 0; i < n; i++) 
 ...
```

例子，重写atoi函数：

```c
#include <ctype.h>
/* atoi: convert s to integer; version 2 */
int atoi(char s[])
{
    int i, n, sign;
    for (i = 0; isspace(s[i]); i++) /* skip white space */
        ;
    sign = (s[i] == '-') ? -1 : 1;
    if (s[i] == '+' || s[i] == '-') /* skip sign */
        i++;
    for (n = 0; isdigit(s[i]); i++)
        n = 10 * n + (s[i] - '0');
    return sign * n;
}
```

把循环控制部分集中在一起，对于多重嵌套循环，优势更为明显。下面的函数是对整型数组进行排序的 Shell 排序算法。Shell 排序算法是 D. L. Shell 于 1959 年发明的，其基本思想是：先比较距离远的元素，而不是像简单交换排序算法那样先比较相邻的元素。这样可以快速减少大量的无序情况，从而减轻后续的工作。被比较的元素之间的距离逐步减少，直到减少为 1，这时排序变成了相邻元素的互换。

```c
/* shellsort: sort v[0]...v[n-1] into increasing order */
void shellsort(int v[], int n)
{
    int gap, i, j, temp;
    for (gap = n / 2; gap > 0; gap /= 2)
        for (i = gap; i < n; i++)
            for (j = i - gap; j >= 0 && v[j] > v[j + gap]; j -= gap)
            {
                temp = v[j];
                v[j] = v[j + gap];
                v[j + gap] = temp;
            }
}
```

逗号运算符“,”也是 C 语言优先级最低的运算符，在 for 语句中经常会用到它。被逗号分隔的一对表达式将按照从左到右的顺序进行求值，表达式右边的操作数的类型和值即为其结果的类型和值。
```c
#include <string.h>
/* reverse: reverse string s in place */
void reverse(char s[])
{
    int c, i, j;
    for (i = 0, j = strlen(s) - 1; i < j; i++, j--)
    {
        c = s[i];
        s[i] = s[j];
        s[j] = c;
    }
}
```
某些情况下的逗号并不是逗号运算符，比如分隔函数参数的逗号，分隔声明中变量的逗号等，这些逗号并不保证各表达式按从左至右的顺序求值。

应该慎用逗号运算符。逗号运算符最适用于关系紧密的结构中，比如上面的 reverse 函数内的 for 语句，对于需要在单个表达式中进行多步计算的宏来说也很适合。逗号表达式还适用于 reverse 函数中元素的交换，这样，元素的交换过程便可以看成是一个单步操作。

### 3.6 do-while 循环

我们在第 1 章中曾经讲过，while 与 for 这两种循环在循环体执行前对终止条件进行测试。与此相反，C 语言中的第三种循环——do-while 循环则在循环体执行后测试终止条件，这样循环体至少被执行一次。do-while 循环的语法形式如下：

```c
do 
  语句
while (表达式);
```

在这一结构中，先执行循环体中的语句部分，然后再求表达式的值。如果表达式的值为真，则再次执行语句，依此类推。当表达式的值变为假，则循环终止。

经验表明，do-while 循环比 while 循环和 for 循环用得少得多。尽管如此，do-while
循环语句有时还是很有用的。下面我们通过函数 itoa 来说明这一点。itoa 函数是 atoi 函数的逆函数，它把数字转换为字符串。这个工作比最初想像的要复杂一些。如果按照 atoi 函数中生成数字的方法将数字转换为字符串，则生成的字符串的次序正好是颠倒的，因此，我们首先要生成反序的字符串，然后再把该字符串倒置。

```c
/* itoa: convert n to characters in s */
void itoa(int n, char s[])
{
    int i, sign;
    if ((sign = n) < 0) /* record sign */
        n = -n;         /* make n positive */
    i = 0;
    do
    {                          /* generate digits in reverse order */
        s[i++] = n % 10 + '0'; /* get next digit */
    } while ((n /= 10) > 0);   /* delete it */
    if (sign < 0)
        s[i++] = '-';
    s[i] = '\0';
    reverse(s);
}
```

### 3.7 break 与 continue 语句

不通过循环头部或尾部的条件测试而跳出循环，有时是很方便的。break 语句可用于从for、while与do-while等循环中提前退出，就如同从switch语句中提前退出一样。break语句能使程序从 switch 语句或最内层循环中立即跳出。

下面的函数 trim 用于删除字符串尾部的空格符、制表符与换行符。当发现最右边的字符为非空格符、非制表符、非换行符时，就使用 break 语句从循环中退出。

```c
/* trim: remove trailing blanks, tabs, newlines */
int trim(char s[])
{
    int n;
    for (n = strlen(s) - 1; n >= 0; n--)
        if (s[n] != ' ' && s[n] != '\t' && s[n] != '\n')
            break;
    s[n + 1] = '\0';
    return n;
}
```

strlen 函数返回字符串的长度。for 循环从字符串的末尾开始反方向扫描寻找第一个不是空格符、制表符以及换行符的字符。当找到符合条件的第一个字符，或当循环控制变量 n 变为负数时（即整个字符串都被扫描完时），循环终止执行。读者可以验证，即使字符串为空或仅包含空白符，该函数也是正确的。

continue 语句与 break 语句是相关联的，但它没有 break 语句常用。continue 语句用于使 for、while 或 do-while 语句开始下一次循环的执行。在 while 与 do-while语句中，continue 语句的执行意味着立即执行测试部分；在 for 循环中，则意味着使控制转移到递增循环变量部分。**continue 语句只用于循环语句，不用于 switch 语句。**某个循环包含的 switch 语句中的 continue 语句，将导致进入下一次循环。

当循环的后面部分比较复杂时，常常会用到 continue 语句。这种情况下，如果不使用continue 语句，则可能需要把测试颠倒过来或者缩进另一层循环，这样做会使程序的嵌套更深。

### 3.8 goto 语句与标号

C 语言提供了可随意滥用的 goto 语句以及标记跳转位置的标号。从理论上讲，goto 语句是没有必要的，实践中不使用 goto 语句也可以很容易地写出代码。至此，本书中还没有使用 goto 语句。

但是，在某些场合下 goto 语句还是用得着的。最常见的用法是终止程序在某些深度嵌套的结构中的处理过程，例如一次跳出两层或多层循环。这种情况下使用 break 语句是不能达到目的的，它只能从最内层循环退出到上一级的循环。下面是使用 goto 语句的一个例子：

```c
for (...)
    for (...)
    {
        ... if (disaster) goto error;
    }
... error:
    /* clean up the mess */
```

标号的命名同变量命名的形式相同，标号的后面要紧跟一个冒号。标号可以位于对应的
goto 语句所在函数的任何语句的前面。标号的作用域是整个函数。

我们来看另外一个例子。考虑判定两个数组 a 与 b 中是否具有相同元素的问题。一种可能的解决方法是：

```c
for (i = 0; i < n; i++)
    for (j = 0; j < m; j++)
        if (a[i] == b[j])
            goto found;
/* didn't find any common element */
... found :
    /* got one: a[i] == b[j] */
    ...
```

所有使用了 goto 语句的程序代码都能改写成不带 goto 语句的程序，但可能会增加一些额外的重复测试或变量。例如，可将上面判定是否具有相同数组元素的程序段改写成下列形式：

```c
found = 0;
for (i = 0; i < n && !found; i++)
    for (j = 0; j < m && !found; j++)
        if (a[i] == b[j])
            found = 1;
if (found)
/* got one: a[i-1] == b[j-1] */
... else
    /* didn't find any common element */
    ...
```

大多数情况下，使用 goto 语句的程序段比不使用 goto 语句的程序段要难以理解和维护，少数情况除外，比如我们前面所举的几个例子。尽管该问题并不太严重，但我们还是建议尽可能少地使用 goto 语句。

!!! note
    总之，别用 goto 语句。