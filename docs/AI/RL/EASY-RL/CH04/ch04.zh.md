# 第四章 策略梯度

## 关键词

- **策略（policy）**：在每一个演员中会有对应的策略，这个策略决定了演员的后续动作。具体来说，策略就是对于外界的输入，输出演员现在应该要执行的动作。一般地，我们将策略写成 $\pi$ 。

- **回报（return）**：一个回合（episode）或者试验（trial）得到的所有奖励的总和，也被人们称为总奖励（total reward）。一般地，我们用 $R$ 来表示它。

- **轨迹（trajectory）**：一个试验中我们将环境输出的状态 $s$ 与演员输出的动作 $a$ 全部组合起来形成的集合称为轨迹，即 $\tau=\left\{s_{1}, a_{1}, s_{2}, a_{2}, \cdots, s_{t}, a_{t}\right\}$ 。

- **奖励函数（reward function）**：用于反映在某一个状态采取某一个动作可以得到的奖励分数，这是一个函数。即给定一个状态-动作对 ($s_1$,$a_1$) ，奖励函数可以输出 $r_1$ 。给定 ($s_2$,$a_2$)，它可以输出 $r_2$。 把所有的 $r$ 都加起来，我们就得到了 $R(\tau)$ ，它代表某一个轨迹 $\tau$ 的奖励。

- **期望奖励（expected reward）**：$\bar{R}_{\theta}=\sum_{\tau} R(\tau) p_{\theta}(\tau)=E_{\tau \sim p_{\theta}(\tau)}[R(\tau)]$。

- **REINFORCE**：基于策略梯度的强化学习的经典算法，其采用回合更新的模式。


## 习题

**4-1** 如果我们想让机器人自己玩视频游戏，那么强化学习中的3个组成部分（演员、环境、奖励函数）具体分别代表什么？

演员做的事情就是操控游戏的摇杆，比如向左、向右、开火等操作；环境就是游戏的主机，负责控制游戏的画面、控制怪物如何移动等；奖励函数就是当执行什么动作、发生什么状况的时候，我们可以得到多少分数，比如击杀一只怪兽得到20分、被对手暴击扣除10分、完成任务得到10分等。

**4-2** 在一个过程中，一个具体的轨迹{$s_1 , a_1 , s_2 , a_2$}出现的概率取决于什么？

（1）一部分是环境的行为，即环境的函数内部的参数或内部的规则是什么形式的。 $p(s_{t+1}|s_t,a_t)$ 这一项代表的是环境，环境这一项通常是无法控制的，因为它是已经客观存在的，或者其形式是提前制定好的。
  
（2）另一部分是智能体的行为，我们能控制的是 $p_\theta(a_t|s_t)$ ，即给定一个状态 $s_t$，演员要采取什么样的动作 $a_t$ 取决于演员的参数 $\theta$，所以这部分是我们可以控制的。随着演员动作的不同，每个同样的轨迹，它会因为不同的概率从而表现出不同的行为。

**4-3** 当我们最大化期望奖励时，应该使用什么方法？

应该使用梯度上升法，因为要让期望奖励越大越好，所以是梯度上升法。梯度上升法在更新参数的时候要添加梯度信息。要进行梯度上升，我们先要计算期望奖励 $\bar{R}$ 的梯度。我们对 $\bar{R}$ 取一个梯度，这里只有 $p_{\theta}(\tau)$ 是与 $\theta$ 有关的，所以 $p_{\theta}(\tau)$ 为梯度的部分。

**4-4** 我们应该如何理解策略梯度的公式呢？

策略梯度的公式如下：

$$
\begin{aligned}
E_{\tau \sim p_{\theta}(\tau)}\left[R(\tau) \nabla \log p_{\theta}(\tau)\right] &\approx \frac{1}{N} \sum_{n=1}^{N} R\left(\tau^{n}\right) \nabla \log p_{\theta}\left(\tau^{n}\right) \\
&=\frac{1}{N} \sum_{n=1}^{N} \sum_{t=1}^{T_{n}} R\left(\tau^{n}\right) \nabla \log p_{\theta}\left(a_{t}^{n} \mid s_{t}^{n}\right)
\end{aligned}
$$

$p_{\theta}(\tau)$ 里面有两项，$p(s_{t+1}|s_t,a_t)$ 来自环境，$p_\theta(a_t|s_t)$ 来自智能体。 $p(s_{t+1}|s_t,a_t)$ 由环境决定，从而与 $\theta$ 无关，因此 $\nabla \log p(s_{t+1}|s_t,a_t) =0$ ， $\nabla p_{\theta}(\tau)=\nabla \log p_{\theta}\left(a_{t}^{n} | s_{t}^{n}\right)$。

具体来说：

（1）假设在状态 $s_t$ 时执行动作 $a_t$，最后发现轨迹 $\tau$ 的奖励是正的，那我们就要增大这一项的概率，即增大在状态 $s_t$ 时执行动作 $a_t$ 的概率；

（2）反之，在状态 $s_t$ 时执行动作 $a_t$ 会导致轨迹 $\tau$ 的奖励变成负的，我们就要减小这一项的概率。

**4-5** 我们可以使用哪些方法来进行梯度提升的计算？

用梯度提升来更新参数，对于原来的参数 $\theta$ ，可以将原始的 $\theta$ 加上更新梯度，再乘一个学习率。通常学习率也需要调整，与神经网络一样，我们可以使用 Adam、RMSProp、SGD 等优化器对其进行调整。

**4-6** 进行基于策略梯度的优化的技巧有哪些？

（1）增加基线：为了防止所有奖励都为正，从而导致每一个状态和动作的变换，都会使得每一项变换的概率上升，我们把奖励减去一项 $b$，称之为基线。当减去 $b$ 后，就可以让奖励 $R(\tau^n)-b$ 有正有负。所以如果得到的总奖励 $R(\tau^n)$ 大于 $b$ ，就让它的概率增大。如果总奖励小于 $b$，就算它是正的，值很小也是不好的，就需要让这一项的概率减小。如果奖励 $R(\tau^n)$ 小于 $b$ ，就要让采取这个动作的奖励下降，这样也符合常理。但是使用基线会让本来奖励很大的“动作”的奖励变小，从而降低更新速率。

（2）指派合适的分数：首先，原始权重是整个回合的总奖励。现在改成从某个时间点 $t$ 开始，假设动作是在时间点 $t$ 被执行的，从时间点 $t$，一直到游戏结束所有奖励的总和大小，才真正代表这个动作是好的还是不好的；接下来我们再进一步，把未来的奖励打一个折扣，我们称由此得到的奖励的和为折扣回报。

（3）综合以上两种技巧，我们将其统称为优势函数，用 $A$ 来代表优势函数。优势函数取决于状态和动作，即我们需计算的是在某一个状态 $s$ 采取某一个动作 $a$ 的时候，优势函数有多大。

（4）优势函数的意义在于衡量假设我们在某一个状态 $s_t$ 执行某一个动作 $a_t$，相较于其他可能动作的优势。它在意的不是绝对的好，而是相对的好，即相对优势，因为会减去一个基线 $b$ 。 $A_{\theta}\left(s_{t}, a_{t}\right)$ 通常可以由一个网络预估出来，这个网络叫作评论员。

**4-7** 对于策略梯度的两种方法，蒙特卡洛强化学习和时序差分强化学习两种方法有什么联系和区别？

（1）两者的更新频率不同。蒙特卡洛强化学习方法是每一个回合更新一次，即需要经历完整的状态序列后再更新，比如贪吃蛇游戏，贪吃蛇“死了”即游戏结束后再更新。而时序差分强化学习方法是每一步就更新一次，比如贪吃蛇游戏，贪吃蛇每移动一次（或几次）就进行更新。相对来说，时序差分强化学习方法比蒙特卡洛强化学习方法更新的频率更高。

（2）时序差分强化学习方法能够在知道一个小步后就进行学习，相比于蒙特卡洛强化学习方法，其更加快速和灵活。

（3）具体例如：假如我们要优化开车去公司的通勤时间。对于此问题，每一次通勤，我们将到达不同的路口。对于时序差分强化学习方法，其会对每一个经过的路口计算时间，例如在路口 A 就开始更新预计到达路口 B、路口 C $\cdots \cdots$ ，以及到达公司的时间；对于蒙特卡洛强化学习方法，其不会每经过一个路口就更新时间，而是到达最终的目的地后，再修改到达每一个路口和到达公司对应的时间。

**4-8** 请详细描述REINFORCE算法的计算过程。

首先我们需要根据一个确定好的策略模型来输出每一个可能动作的概率，对于所有动作的概率，我们使用采样方法（或者是随机的方法）选择一个动作与环境进行交互，同时环境会给我们反馈整个回合的数据。将此回合数据输入学习函数中，并根据回合数据进行损失函数的构造，通过Adam等优化器的优化，再更新我们的策略模型。


## 面试题

**4-1** 友善的面试官：同学来吧，给我手动推导一下策略梯度公式的计算过程。

首先我们的目的是最大化奖励函数，即调整 $\theta$ ，使得期望回报最大，可以用公式表示如下：

$$
J(\theta)=E_{\tau \sim p_{\theta(\tau)}}\left[\sum_tr(s_t,a_t)\right]
$$

其中 $\tau$ 表示从开始到结束的一条完整轨迹。通常对于最大化问题，我们可以使用梯度上升算法找到最大值，即

$$
\theta^* = \theta + \alpha\nabla J({\theta})
$$

所以我们仅仅需要计算并更新 $\nabla J({\theta})$ ，也就是计算奖励函数 $J({\theta})$ 关于 $\theta$ 的梯度，也就是策略梯度，计算方法如下：

$$
\nabla_{\theta}J(\theta) = \int {\nabla}_{\theta}p_{\theta}(\tau)r(\tau) \mathrm{d}{\tau}=\int p_{\theta}{\nabla}_{\theta} \mathrm{log}p_{\theta}(\tau)r(\tau)\mathrm{d}{\tau}=E_{\tau \sim p_{\theta}(\tau)}[{\nabla}_{\theta}\mathrm{log}p_{\theta}(\tau)r(\tau)]
$$

接着我们继续展开，对于 $p_{\theta}(\tau)$ ，即 $p_{\theta}(\tau|{\theta})$ ：

$$
p_{\theta}(\tau|{\theta}) = p(s_1)\prod_{t=1}^T \pi_{\theta}(a_t|s_t)p(s_{t+1}|s_t,a_t)
$$

取对数后为：

$$
\mathrm{log}p_{\theta}(\tau|{\theta}) = \mathrm{log}p(s_1)+\sum_{t=1}^T \mathrm{log}\pi_{\theta}(a_t|s_t)p(s_{t+1}|s_t,a_t)
$$

继续求导：

$$
\nabla \mathrm{log}p_{\theta}(\tau|{\theta}) = \sum_{t=1}^T \nabla_{\theta}\mathrm{log} \pi_{\theta}(a_t|s_t)
$$

代入第3个式子，可以将其化简为：

$$
\begin{aligned}
    \nabla_{\theta}J(\theta) 
    &= E_{\tau \sim p_{\theta}(\tau)}[{\nabla}_{\theta}\mathrm{log}p_{\theta}(\tau)r(\tau)] \\
    &= E_{\tau \sim p_{\theta}}[(\nabla_{\theta}\mathrm{log}\pi_{\theta}(a_t|s_t))(\sum_{t=1}^Tr(s_t,a_t))] \\
    &= \frac{1}{N}\sum_{i=1}^N[(\sum_{t=1}^T\nabla_{\theta}\mathrm{log} \pi_{\theta}(a_{i,t}|s_{i,t}))(\sum_{t=1}^Nr(s_{i,t},a_{i,t}))]    
\end{aligned}
$$

**4-2** 友善的面试官：可以说一下你所了解的基于策略梯度优化的技巧吗？

（1）增加基线：为了防止所有奖励都为正，从而导致每一个状态和动作的变换，都会使得每一个变换的概率上升，我们把奖励减去一项 $b$，称 $b$ 为基线。当减去 $b$ 以后，就可以让奖励 $R(\tau^n)-b$ 有正有负。如果得到的总奖励 $R(\tau^n)$ 大于 $b$ ，就让它的概率上升。如果总奖励小于 $b$，就算它是正的，值很小也是不好的，就需要让它的概率下降。如果总奖励小于 $b$ ，就要让采取这个动作的奖励下降，这样也符合常理。但是使用基线会让本来奖励很大的“动作”的奖励变小，降低更新速率。

（2）指派合适的分数：首先，原始权重是整个回合的总奖励。现在改成从某个时间点 $t$ 开始，假设这个动作是在时间点 $t$ 被执行的，那么从时间点 $t$ ，一直到游戏结束所有奖励的总和，才真的代表这个动作是好的还是不好的；接下来我们再进一步，把未来的奖励打一个折扣，这里我们称由此得到的奖励的和为折扣回报。

（3）综合以上两种技巧，我们将其统称为优势函数，用 $A$ 来代表优势函数。优势函数取决于状态和动作，即我们需计算的是在某一个状态 $s$ 采取某一个动作 $a$ 的时候，优势函数有多大。
